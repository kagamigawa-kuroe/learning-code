#### 进程

**进程**是程序执行的一个实例，是系统进行资源调度和分配的的基本单位，**线程**是**进程**的子任务，是CPU调度和分派的基本单位。

**三种线程**  内核线程、轻量级进程、用户线程

内核线程能在内核内部，自己使用的线程，也包括用户态通过**系统调用**产生的线程。 用户线程就是不涉及内核的线程，也就是在使用的时候**内核无感知**。

在用户线程的情况下，资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用，也就是一个进程的多个线程是没有办法同步执行的。

轻量级进程是在linux内核发展过程中，为了减少切换进程带来的开销，由**内核提供**的一种线程模式，主要由clone函数实现，可以指定要创建一个普通进程还是轻量级线程。对于用户态来说，可以通过直接调用轻量级进程来实现多线程。linux中的pthread就是这么做的。

```
1.fork, vfork and clone三者最终都会调用do_fork(或者是kernel_clone)函数，三者的差别就是参数上的不同而已。
fork的实现：
   do_fork(CLONE_SIGCHLD,...)
clone的实现：
    do_fork(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGCHLD,...)
vfork的实现：
     do_fork(CLONE_VFORK|CLONE_VM|CLONE_SIGCHLD,...)

实际上产生效果的也是这些参数：

CLONE_VM标识：表示共享地址空间（变量等）

CLONE_FILES标志：表示共享文件描述符表

CLONE_VFORK标识：标识父进程会被阻塞，子进程会把父进程的地址空间锁住，直到子进程退出或执行exec时才释放该锁

SIGCHLD标识：共享信号

do_fork在复制进程描述符的时候，又会使用copy_process函数
```

---

#### 进程和线程的切换效率

在进行进程切换时，涉及**当前执行进程 CPU 环境的保存**及**新调度进程 CPU 环境的设置**，而线程切换时只需保存和**设置少量寄存器内容**，开销很小。

各种内核数据结构：比如描绘地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。

**那么线程切换和进程切换有什么区别呢？**

每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间。那么其中最主要的一个区别在于**进程切换涉及虚拟地址空间的切换而线程不会。**

**那么为什么虚拟地址空间切换会比较耗时呢？**

因为进程有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找表，页表查找很慢，所以通过有个cache就是TLB。

那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了。所以线程切换要比进程切换要大。

---

#### 进程描述符

为了清楚的表示一个进程所做的事，我们用进程描述符去记录下他的一系列信息，例如优先级，地址空间，访问的文件等等。

进程描述符都是**task_struct**结构, 包含的信息有:

- 标识符：描述本进程的唯一标识符，用于区别其他进程
- 状态：任务状态，退出信号，退出代码，优先级等
- 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针 mm_struct
- 程序计数器：程序中即将被执行的下一条指令的地址
- 上下文数据：进程执行时处理器的寄存器中的数据
- IO状态信息：包括显示的 I/O 请求，分配给进程的 I/O 设备和被进程使用的文件列表。

主要涉及的数据结构包括:

- thread_info 基本信息
- mm_struct 内存信息
- tty_struct tty信息
- fs_struct 目录信息
- files_struct 文件信息
- signal_struct 信号信息

![image-20220913221608160](/Users/whz/Library/Application Support/typora-user-images/image-20220913221608160.png)

----

#### 进程状态

**模型**中 一般分为五类状态：

就绪（Ready）：程序等待执行

运行（Running）：程序正在执行

堵塞（Blocked）：进程执行了某些操作需要等待其运行，如：IO 操作

初始（Initial）：进程在创建时的状态

最终（Final）：退出但没有清理，使得其他进程可以得取返回值



**在linux系统中**，有几下几种状态：

可运行状态，

可中断的等待状态，

不可中断的等待状态，

暂停状态，

僵死状态，

僵死撤销状态。

----

#### 进程标识

linux使用唯一的进程标识符，一般是小于32768的整数 /proc/sys/kernel/pid_max

linux将所有的标识符都放在pidmap-array中，以记录已经使用的标识符，一般有一个专门的页用来存储这个信息。

thread_info结构记录了进程一系列的信息，被放在进程内核栈中，task_struct中记录了其地址。

linux内核会维护一个双向链表，将需要运行的进行都放入这个链表中，然后依次执行。

同时，为了能从一个pid导出一个进程描述符，linux内核还维护了一个pidhash表，用于映射。

---

#### 进程关系

程序之间存在父子关系，如果多个程序是一个父进程产生的，那么他们就是兄弟关系。

进程描述符中就有指针会专门指向父亲进程，以及兄弟进程。

---

#### 等待队列

为了维护所有的陷入等待的进程，内核用一个队列来存储所有的等待进程，并用自旋锁保证安全。

为了区别同时同时唤醒等待同一资源的多个进程，队列中还会对进程进行细分，对于不互斥的进程，直接换行，对于互斥的，只唤醒其中一个。

----

#### 资源限制

资源限制信息被放置在信号描述信息的一部分，名为rlim字段。每个资源限制对应其中一个字段。

----

#### 进程切换

硬件式切换，通过进程描述符中的tss字段，直接将其装载入cpu寄存器中

linux使用的是软件切换，将寄存器内容存储在内核的堆栈区，不用tss字段

切换过程：

> 主要的内核函数位schedule函数
>
> 1. 切换全局目录页，以更新地址空间
> 2. 切换硬件上下文

>Schedule函数的主要流程
>
>schedule函数 通过rq(存储调度信息的结构体) 调用 pick_next_task函数 得到下一个任务next 然后执行context_switch函数 其核心是一个to_switch汇编函数
>
>to__switch的三个参数比较难理解，为什么除了prex next 还需要一个last 
>
>进程A切换到B后，过了一段时间再从C切换到A时，A需要知道自己是从哪个进程切换到的，即需要C的地址。

----

#### 任务状态段tss

cpu中的一个特殊的段类型，用于硬件上下文切换。

任务状态段TSS（Task-state segment）是一块104字节的内存，用于存储大部分寄存器的值。CPU中无进程和线程的概念（这是操作系统的概念），CPU中只有任务概念（任务对应操作系统的线程）。1个CPU核只有一个TR寄存器，存储了当前TSS。

虽然linux不实用tss进行上下文切换，但是tss还是有其存在必要性，例如用户内核态切换的时候，就是通过TSS字段来找到内核态的地址，

---

#### 线程之间资源的共享

【同一进程间的线程共享的资源有】

a. 堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）

b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的

c. 静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的

d. 文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。

【独享的资源有】

a. 栈 栈是独享的

b. 寄存器  

---

#### 内核线程

在linux启动过程中 首先会被创建出一个0号进程，0号进程调用kernel_thread函数(这个函数的本质就是do_fork，参数被固定)，创建出内核线程1，执行init函数，并被装载进程序init，

同时，还有很多初始化线程也会被在系统启动时创建，基本都是在/etc/rcX.d下面的文件

---

#### 进程中止

进程中止在linux中有两种系统调用: exit_group() 和 exit(),对应底层的函数分别是do_group_exit()和do_exit()

---

#### 进程调度

linux中进程的优先级被分为-20-+19，越大优先级越高, 可以用nice命令修改运行程序的优先级

时间片: 时间片是一个进程在被抢占前能运行的时间，是分配的最小单位。在大部分os中都被设置的很短。

linux的调度策略是模块化的，一个调度器中可以存在多种策略，然后根据策略的优先级去选择调用。

常见的策略有：`CFS`完全公平调度，FIFO，短作业优先，短完成时间优先，HRRN高响应占比(综合比较等待时间和要求服务时间)，时间片轮转()，多级反馈队列。。

进程调度相关的信息被存在tast_struct中的sched_entity中。

调度的入口函数为schedule()



公平调度：最基本的调度理念，进程按照权重比例分配在cpu上可以运行的时间。

具体实现: 通过红黑树找到运行时间最小的节点，然后执行.



实时调度策略:

1. FIFO
2. RR 在耗尽事先分配的时间片之后就不会继续执行



在切换进程时，具体的调用函数为context_switch函数，主要有两项工作

- switch_mm 切换虚拟内存
- switch_to 切换cpu状态 包括保存和恢复栈信息，寄存器信息等



- 用户态抢占(重新调度)
  - 从系统调用返回用户空间时，read，write，syscall
  - 从中断处理程序返回用户空间时，硬件中断，时钟中断(类似于时间片的概念)，等等
- 内核态抢占(重新调度)
  - 中断处理程序正在执行，且返回内核空间之前
  - 内核代码再一次具有可抢占性的时候
  - 内核任务显式的调用`schedule()`
  - 内核任务阻塞







