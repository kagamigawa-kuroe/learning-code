#### 死锁的产生和解决

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

可以通过在使用前对资源进行检验（银行家算法）, 通过引用计数，通过转让资源所有权，总之破坏上述四个条件之一即可

---

#### 原子变量

使用atomic_t类型

```c
atomic_t v; // 定义一个原子变量
atomic_t u = ATOMIC_INIT(0); // 定义并初始化
atomic_set(&v,10); // 设置值
atomic_add(2，&v); // 加法
int a = atomic_read(v); //将原子量转换为int
```

atomic底层的定义

```c
typedef struct {
   volatile int counter;
} atomic_t;
```

---

#### 自旋锁

spinlock 在资源获取失败的时候，不会陷入休眠，而是会一直持续尝试访问资源，这减少的cpu陷入休眠的切换时间

一般来说，如果我们知道某个进程对资源的占用时间并不长，就可以在别的线程申请这个资源的时候使用自旋锁

---

#### BKL大内核锁

BKL是一个全局的锁（注意，是“一个”而不是“一种”），它保护所有使用它来同步的临界区。一旦一个进程获得BKL，进入被它保护的临界区，不但该临界区被上锁，所有被它保护的临界区都一起被锁住。
他是递归的，且上锁的进程也可以陷入沉睡，当任务无法被调度时，会自动去锁

---

#### 顺序锁

在2.6内核被引入的新锁，在读取一个数据时，都会获取其一个唯一的序列号，每次这个数据被改动时，序列号都会+1，当你读取数据，然后修改，再将其写入时，如果发现序列号和读取的时候不一致，则说明数据失效，需要重新执行

---

#### 屏障

为了保证变量的读取和写入按顺序执行(有时候在运行时，编译器优化后会导致代码不按照顺序进行)，我们需要用到屏障

rmb() 读屏障 wmb()写屏障 mb() 读写屏障