#### 逻辑地址 线性地址 物理地址

注意地址 不一定储存变量 也有可能是指令

- 逻辑地址由段和偏移量构成，是程序运行中使用的地址，段一般是一个16为的字段，成为**段选择符**，以及一个偏移量，一般是32位的字段

- 线性地址是由逻辑地址的段+偏移量,推算得出的地址,是物理地址和逻辑地址的中间层

- 如果有分页机制 那么物理地址 也就是真实运行在cpu中的地址需要进一步从线性地址推导得出。

为了方便的确定程序的段选择符，处理器一般都会有一个专门的寄存器，用来存储段信息。其中又分为代码段寄存器(代码指令)，栈段寄存器(一般变量)，全局段寄存器(全局静态变量)。

每一个段，在系统中，都有一个**段描述符**对应，记录着这个段的信息，权限，起始地址等。所有的段描述符，都放在全局或者局部描述表中。同理，描述符也根据地址储存的内容不同，也有对应的区别。段描述符也有对应的寄存器，当段选择符被装入寄存器，段描述符也会被装入专门的寄存器，从而提高查找效率。只有当需要修改段的信息时，才回去内存中寻找。

---

#### 逻辑地址转化线性地址的过程

拿到段选择符，根据选择符，去全局或者局部描述表中，找到对应的描述符信息，根据信息中的地址，与选择符中的偏移量一起，共同计算得出线性地址。

---

#### 分页和分段

分页是将内存划分为相同大小的块，并且必须按照块的大小申请和使用，该大小由操作系统决定。

分段是根据程序的需要，划分出不同大小的内存块，供其使用。

分段为每一个进程分配不同的空间，而分页允许不同的进程使用相同的空间，然后进行映射。

在设计之初 分段是为了将逻辑地址转化为线性地址 分页是为了将线性地址转化为真实地址

由于分页管理更适合现代操作系统，所以分段管理基本已经被淘汰了(这里的淘汰 实际上是被架空了 也就是对于一段程序中的内存 不论其是什么 我们总是将段的起始地址从0开始 这样就巧妙的屏蔽了分段的设置)

|      | 分页                                                         | 分段                                                         |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 1.   | 程序被分成大小相等的部分，称为页面，以将它们存储在主内存中。 | 程序被分割成可变大小的部分，称为段，以将它们存储在主内存中。 |
| 2.   | 分页是由操作系统完成的。                                     | 分段由编译器完成。                                           |
| 3.   | 它可以将相同功能的代码存储到不同的页面中。                   | 它将相同的功能存储在一个段中。                               |
| 4.   | 这会导致系统效率降低，因为要执行一个功能，我们可能需要访问多个页面。 | 由于编译器在一个段中保留了相同类型的函数，因此它会产生一个更高效的系统。 |
| 5.   | 页表用于存储有关页面和框架的详细信息。                       | 段表用于存储段的详细信息。                                   |
| 6.   | 为了将逻辑地址转换为物理地址，使用具有<页号，帧号>的页表条目。 | 为了将逻辑地址转换为物理地址，使用具有<基地址，限制>的段表条目。 |
| 7.   | 与分段相比，分页速度更快。                                   | 分割很慢。                                                   |
| 8.   | 当程序大小小于确定的页面大小时，分页会导致内部碎片。         | 在删除一些导致小孔的程序后，分段会导致外部碎片。             |
| 9.   | 逻辑地址由两部分组成：页码和页偏移量。                       | 逻辑地址由两部分组成：段号和段偏移量。                       |
| 10.  | 在分页中，操作系统维护一个可以分配给页面的空闲帧列表。       | 在分段中，操作系统维护存在于主内存中的空洞列表。             |
| 11.  | 页被认为是信息的物理单元。                                   | 段被认为是信息的逻辑单元。                                   |
| 12.  | 分页的概念对用户来说是完全隐藏的。                           | 分割的概念对用户是可见的。                                   |
| 13.  | 在分页中，页面的大小总是等于帧的大小。                       | 在分段中，对分段的大小没有限制。                             |

---

#### 分页

在线性地址转换为物理地址的过程中，线性地址被划分为固定长度的组，成为**页**，同时 ，物理地址也会被划分为同样大小的许多块，成为**页框**，或者**物理页**，在映射时，我们将每一个页映射到页框上，这样可以更合理的分配内存。

储存这种映射规则的数据结构，被称为**页表**。

常规分页的规则是：目录+页表+偏移量

但现在一般使用的更为简单 是 **目录+偏移量**的形式

一个页表中含有如下的信息：

- present标志 表示其是否在内存中
- 页框的起始地址
- Access标志 被使用就会设置这个标志 用于页置换算法
- dirty标志 当进行写操作时就会修改这个标志 和上面access类似
- 读写权限
- 。。。

要注意页表，线性地址的区分

线性地址由 页号 + 偏移量 组成

页表中的内容，也就是页表项，也是由页号的，但是由页表 + 页表映射的物理地址 组成

当我们进行地址访问时，根据线性地址中的页号，去页表项中查找页号，找到其对应的物理地址，加上偏移量，就是我们需要访问的地址

再来说说**页表项的大小** ：一个32位的系统，地址空间总计2^32次方，页表大小一般为4kb，那么我们一共需要 2^32/4kb = 2^20次方个页表，也就是需要20位bit，才能表示出一个页表。所以在页表项中，一般是12bit的线性地址+20bit的页框的起始地址。

---

![image-20220906231552558](/Users/whz/Library/Application Support/typora-user-images/image-20220906231552558.png)

---

#### 多级页表的原因

之前提到 如果一个页表的大小为4kb，那么就有至少2^20次方个页块，也就是说，在一个页表项中，需要20+20=40bit的大小，对于32位系统来说 这是无法做到的

所以，我们将其分为多级，在页表号前，在加入一级目录。

现在，一个页的大小在许多处理器上变成了4mb(2^22b)，所需的页块就少了(需要32-22=10bit的页块)，那么就不需要多级页表了。

现在的linux内核一般使用3-4级页表

---

#### TLB 快表

TLB - translation lookaside buffer

快表，直译为旁路快表缓冲，也可以理解为页表缓冲，地址变换高速缓存。

由于页表存放在主存中，因此程序每次访存至少需要两次：一次访存获取物理地址，第二次访存才获得数据。提高访存性能的关键在于依靠页表的访问局部性。当一个转换的虚拟页号被使用时，它可能在不久的将来再次被使用到，。

TLB是一种高速缓存，内存管理硬件使用它来改善虚拟地址到物理地址的转换速度。当前所有的个人桌面，笔记本和服务器处理器都使用TLB来进行虚拟地址到物理地址的映射。使用TLB内核可以快速的找到虚拟地址指向物理地址，而不需要请求RAM内存获取虚拟地址到物理地址的映射关系。这与data cache和instruction caches有很大的相似之处。

---

----

#### 物理页在内存中的表示

在内存中，页被定义在mm_pages.h中 struct page{...} 这个页是实际的页 物理地址 也就是页框

其中包含了如页的状态，页对应的虚拟地址，页的引用计数。

为了区分不同的内存区域，给予一切区域特定的功能，我们将内存划分为不同的区，例如可以直接执行内存访问的区域，需要进行内存映射的区域，以及动态映射的区域(用于物理内存大于逻辑内存的情况)

----

#### 页操作

1. 获取页 ： struct page* alloc_pages(gfp_t gfp_mask,unsigned_int order)
2. 转化为逻辑地址：void* page_address(struct page* page)







