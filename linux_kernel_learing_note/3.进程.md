#### 进程

**进程**是程序执行的一个实例，是系统进行资源调度和分配的的基本单位，**线程**是**进程**的子任务，是CPU调度和分派的基本单位。

**三种线程**  内核线程、轻量级进程、用户线程

内核线程能在内核内部，自己使用的线程，也包括用户态通过**系统调用**产生的线程。 用户线程就是不涉及内核的线程，也就是在使用的时候**内核无感知**。

在用户线程的情况下，资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用，也就是一个进程的多个线程是没有办法同步执行的。

轻量级进程是在linux内核发展过程中，为了减少切换进程带来的开销，由**内核提供**的一种线程模式，主要由clone函数实现，可以指定要创建一个普通进程还是轻量级线程。对于用户态来说，可以通过直接调用轻量级进程来实现多线程。linux中的pthread就是这么做的。

```
1.fork, vfork and clone三者最终都会调用do_fork(或者是kernel_clone)函数，三者的差别就是参数上的不同而已。
fork的实现：
   do_fork(CLONE_SIGCHLD,...)
clone的实现：
    do_fork(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGCHLD,...)
vfork的实现：
     do_fork(CLONE_VFORK|CLONE_VM|CLONE_SIGCHLD,...)

实际上产生效果的也是这些参数：

CLONE_VM标识：表示共享地址空间（变量等）

CLONE_FILES标志：表示共享文件描述符表

CLONE_VFORK标识：标识父进程会被阻塞，子进程会把父进程的地址空间锁住，直到子进程退出或执行exec时才释放该锁

SIGCHLD标识：共享信号
```

---

#### 进程和线程的切换效率

在进行进程切换时，涉及**当前执行进程 CPU 环境的保存**及**新调度进程 CPU 环境的设置**，而线程切换时只需保存和**设置少量寄存器内容**，开销很小。

各种内核数据结构：比如描绘地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。

**那么线程切换和进程切换有什么区别呢？**

每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间。那么其中最主要的一个区别在于**进程切换涉及虚拟地址空间的切换而线程不会。**

**那么为什么虚拟地址空间切换会比较耗时呢？**

因为进程有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找表，页表查找很慢，所以通过有个cache就是TLB。

那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了。所以线程切换要比进程切换要大。

---

#### 进程描述符

为了清楚的表示一个进程所做的事，我们用进程描述符去记录下他的一系列信息，例如优先级，地址空间，访问的文件等等。

进程描述符都是**task_struct**结构, 包含的信息有:

- 标识符：描述本进程的唯一标识符，用于区别其他进程
- 状态：任务状态，退出信号，退出代码，优先级等
- 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针 mm_struct
- 程序计数器：程序中即将被执行的下一条指令的地址
- 上下文数据：进程执行时处理器的寄存器中的数据
- IO状态信息：包括显示的 I/O 请求，分配给进程的 I/O 设备和被进程使用的文件列表。

主要涉及的数据结构包括:

- thread_info 基本信息
- mm_struct 内存信息
- tty_struct tty信息
- fs_struct 目录信息
- files_struct 文件信息
- signal_struct 信号信息

----

#### 进程状态

**模型**中 一般分为五类状态：

就绪（Ready）：程序等待执行

运行（Running）：程序正在执行

堵塞（Blocked）：进程执行了某些操作需要等待其运行，如：IO 操作

初始（Initial）：进程在创建时的状态

最终（Final）：退出但没有清理，使得其他进程可以得取返回值



**在linux系统中**，有几下几种状态：

可运行状态，

可中断的等待状态，

不可中断的等待状态，

暂停状态，

僵死状态，

僵死撤销状态。

----

#### 进程标识

linux使用唯一的进程标识符，一般是小于32768的整数 /proc/sys/kernel/pid_max

linux将所有的标识符都放在pidmap-array中，以记录已经使用的标识符，一般有一个专门的页用来存储这个信息。

thread_info结构记录了进程一系列的信息，被放在进程内核栈中，task_struct中记录了其地址。

linux内核会维护一个双向链表，将需要运行的进行都放入这个链表中，然后依次执行。

同时，为了能从一个pid导出一个进程描述符，linux内核还维护了一个pidhash表，用于映射。

---

#### 进程关系

程序之间存在父子关系，如果多个程序是一个父进程产生的，那么他们就是兄弟关系。

进程描述符中就有指针会专门指向父亲进程，以及兄弟进程。

---

#### 等待队列

为了维护所有的陷入等待的进程，内核用一个队列来存储所有的等待进程，并用自旋锁保证安全。

为了区别同时同时唤醒等待同一资源的多个进程，队列中还会对进程进行细分，对于不互斥的进程，直接换行，对于互斥的，只唤醒其中一个。

----

#### 资源限制

资源限制信息被放置在信号描述信息的一部分，名为rlim字段。每个资源限制对应其中一个字段。

----

#### 进程切换

