#### 中断

**中断**是一个事件，会改变处理器的处理流程。

中断分为**同步中断**和**异步中断**。

同步中断是由cpu自己产生的，又被称为**异常**，如缺页，而异步中断是由间隔定时器和IO设备产生的，例如，用户的按键输入就是外部中断。

外部中断被分为可屏蔽中断和不可屏蔽中断，可屏蔽中断在被设置可屏蔽后，cpu就会忽略

内部异常也被分为几种:

- 故障 在修复后会重新执行
- 陷阱 没有必要重新执行中断的指令
- 异常中止 极其严重的错误，会强制中止进程
- 编程异常，更低级级别的程序产生的错误，如编程时的越界等

中断由一条专门的输出线--IRQ，和一个可编程中断控制器控制。

---

#### 中断切换

当产生一个中断时，会有一个中断信号到达，此时cpu就要停止当前的任务，转而去处理这个中断，所以需要在内核栈中保存当前程序计数器的值，这有点类似于进程的切换，但中断的处理比进程的切换更为轻量级，因为中断处理的并不是一个新的进程，而是一个内核控制路径。

中断在内核中用中断描述符标识，记录了中断信号以及其对应的中断处理函数，通过tss切换被调用。

中断描述符被称为dtr，描述标被称为idtr，有256项目，同时也有gdtr寄存器，指向idtr的地址

所有的中断处理程序以及中断描述符和表 都会在linux内核加载初始化的时候被载入。

中断切换是可以嵌套的，也就是说当一个中断在处理时候，可以发生另一个中断，等新发生的中断处理完，在返回处理原先的中断。

----

#### riq描述符

IRQ (Interrupt ReQuest) 指来自设备的中断请求。 目前，它们可以通过一个引脚或通过一个数据包进入。 多个设备可以连接到同一个引脚，从而共享一个IRQ。

一个irq线可能对应了多个外设，所以在irq被激活时，会调用所有外设的中断处理函数

每一个中断向量都有自己对应的irq描述符(dtr描述的是一种中断(256种的一种)，而irq则是具体的某种中断)

IRQ编号是对机器上可能的中断源的枚举。通常枚举的是系统中所有中断控制器的输入引脚 编号

irq被存储在/proc/irq下 

---

#### 相关的函数

Request_irq : 注册一个irq，也就是分配一条中断线，要穿入一个irq，以及一个处理函数handler

free_irq ： 与上述相反 释放一个irq

do_irq函数 ： 用来具体处理某种irq

---

#### 下半部和软中断

虽然中断是可以嵌套的，但linux中为中断设置了等级，一个中断不能打断级别大于或等于他的中断。

这段时间内，其他中断都无法处理导致中断无法响应，因此需要当前进入的中断子服务函数越快越好。但是在一些特殊情况下，中断要处理的事情可能是复杂且冗长的

为解决这种问题，中断上下半部的概念顺势而生。将中断拆成两部分，上半部用来处理紧急的事情；下半部用来处理不紧急的事情，一般以内核线程的方式执行。

下半部最早的实现方式是**任务队列**：用一个链表队列存储不着急执行的中断。

后来出现了新的解决方式**软中断和tasklet**，其中tasklet更为常用

----

#### 软中断

一个软中断，在内核中由softirq_action标识，内核维护了一个名为softirq_vec的数组，存储了32个软中断，这个大小是不能改变的。

在执行软中断时，调用的是一个名为softirp_handler(softirq_vec* v)的函数 他将整个softirq_vec数组穿入，然后对于数组中的每一个softirq_action，如果检查到需要执行，就去调用他的action函数，执行其处理软中断的程序。

注意上述过程中，被穿入的是整个软中断数组，只有被标记为需要执行的软中断才会执行，被标记的软中断叫触发软中断。

一般检查和执行软中断的时间如下：

- 硬件中断代码返回
- 内核线程
- 主动的显示检查和处理，如网络模块

软中断执行的函数为do_softirq()。也就是softirp_handler实际调用的底层函数

有一个名为ksoftirqd的内核线程 会一直死循环检查软中断并执行do_softirq()

----

#### 注册软中断

首先把自己要加入的tasklet加入到软中断列表中

然后调用open_softirq(tasklet_name,function)函数 注册一个新的软中断

注意 同一个软中断程序可以在不同的cpu上 也就意味着需要一些手段来保证数据安全，如锁，或者使用单处理器数据等。

tasklet不允许一个程序运行在多cpu上，也就没有这样的问题，所以更被推荐

将你的软中断加入到代执行任务中(softirq_vec), 需要使用raise_softirq函数 同理 取消需要使用raise_softirq_irqoff

一旦调用上述函数将软中断处理函数设置为代执行状态，下一次内核调用do_softirq()处理的时候，就会执行这些任务

---

#### Tasklet

tasklet是软中断的另一种实现方式，这里是tasklet的数据结构

![image-20220916150419464](/Users/whz/Library/Application Support/typora-user-images/image-20220916150419464.png)



比起上述软中断的数组，这里使用链表来存储中断，这让其灵活性更高

tasklet的调度：通过_tasklet_schedule函数调度 已被调度的tasklet结构会被放在一个tasklet_vec中，然后后续的流程就和之前提到的软中断处理流程差不多，将某个tasklet设置为可执行，然后在do_softirq()时，就会执行对应的函数

----

#### 操作Tasklet

声明一个tasklet: DECLARE_TASKLET(name,func,data)

调度tasklet：tasklet_schedule(&my_tasklet), 把一个tasklet加入等待队列，在之后do_softirq()的时候，就会被执行





