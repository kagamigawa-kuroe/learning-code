#### 节拍器

linux中对时间的感知，主要通过硬件中的节拍器来实现，节拍器按一定的速率产生信号，而linux系统以这个信号来确定过了多少时间。

---

#### Jiffies

全局变量jiffies用于记录系统启动以来产生的所有节拍数量，这样就可以知道距离系统启动一共过去了多少时间, 可以通过获取jiffies获取当前的时间，也可以在jiffies进行数字运算来获取其他的时间。

---

#### 实时时钟

上面提到的基于节拍器的时间获取模式，本质上是一种系统定时器，只能获取系统启动后的时间。

如果我们需要获取具体的时刻，就需要一个实时时钟。

实时时钟也是基于顶层的硬件设备，在cpu中有一个专门的管理模块，断电了也可以通过电池继续工作，保证了时间的获取

在内核中当前具体时间有xtime记录

---

#### 时钟中断处理程序

节拍器本质其实就定特定间隔时间的中断产生器，我们需要有对应的中断处理函数去处理这个高频率的中断。

这个处理函数要做的事包括但不限于:

1. 获取事件相关全局变量如jiffies和xtime的锁
2. 重新设置 或者 更新 或者 应答当前时间
3. 执行tick_periodic函数，其内容如下
   - jiffies++
   - 执行时间到了的定时器任务
   - 更新xtime时间
   - 执行scheduler_tick函数（用于更新时间片剩余的时间，用于进程的切换与抢占）

---

#### 定时器

在linux内核中 定时器的是一个time_list类型的结构体：

主要成员变量由

- 定时器的链表入口
- 以jiffies作为时间单位的定时器
- 函数 也就是执行任务
- 穿入函数的参数

在上述提到的tick_periodic流程中 就是从结构题中读取出任务执行的时间 判读是否需要执行

使用定时器的流程

1. 定义time_list结构体
2. 使用init_timer函数 进行初始化
3. 设置其中的内容 如时间 执行函数
4. add_timer函数
5. mod_timer()/del_timer()

----

#### 中断与定时器

定时器作为一个高频出发的中断(每秒一千次) 毫无疑问，是软中断使用的极佳场景

节拍器触发的中断会执行一个run_local_timer的函数，这个函数内部会执行软中断, raise_softirq(TIME_SOFTIRQ), TIME_SOFTIRQ在软中断表中对应就是对应定时器的软中断处理

---

#### 延迟执行

1. 忙等待 最简单的延迟执行 就是用while循环 等待一定的时间
2. 更精确的延迟时间 使用udelay ndelay mdelay函数 可以实现微秒级别的延迟控制
3. Schedule_timeout函数 会让当前的任务陷入sleep 一定时间后唤醒 这个函数本质就是用定时器在设置一个唤醒任务 然后将当前的任务陷入休眠



